"""
Tests de integración: Flujo CSP → HoTT → Verificación.

Este módulo valida el flujo completo desde la definición de un problema CSP
hasta su verificación formal en HoTT.
"""
import pytest
from lattice_weaver.core.csp_problem import CSP
from lattice_weaver.formal.csp_integration import translate_csp_to_hott
from lattice_weaver.formal.csp_properties import verify_csp_property, CSPProperty

@pytest.mark.integration
class TestCSPToHoTTFlow:
    """Tests del flujo completo CSP → HoTT → Verificación."""
    
    def test_nqueens_complete_flow(self, nqueens_problem, csp_problem, cubical_engine):
        """
        Test: N-Reinas → Resolución → Traducción HoTT → Verificación.
        
        Flujo:
        1. Resolver problema N-Reinas (n=4)
        2. Verificar que hay soluciones
        3. Traducir problema y solución a HoTT
        4. Verificar propiedad de correctitud
        5. Validar que la prueba type-checks
        
        Este test valida la integración completa entre el motor CSP
        y el sistema formal HoTT.
        """
        # 1. Resolver problema
        solutions = csp_problem.solve(nqueens_problem)
        
        # 2. Verificar soluciones
        assert len(solutions) > 0, "Debe encontrar al menos una solución"
        assert len(solutions) == 2, "N-Reinas con n=4 tiene exactamente 2 soluciones"
        
        # Verificar que las soluciones son válidas
        for solution in solutions:
            assert len(solution) == 4, "Solución debe tener 4 variables"
            assert all(0 <= v < 4 for v in solution.values()), "Valores en rango [0,3]"
        
        # 3. Traducir a HoTT
        hott_problem = translate_csp_to_hott(nqueens_problem)
        hott_solution = translate_csp_to_hott(solutions[0], nqueens_problem)
        
        assert hott_problem is not None, "Traducción de problema debe ser exitosa"
        assert hott_solution is not None, "Traducción de solución debe ser exitosa"
        
        # 4. Verificar propiedad de correctitud
        proof = verify_csp_property(
            nqueens_problem,
            solutions[0],
            CSPProperty.SOLUTION_CORRECTNESS,
            cubical_engine
        )
        
        assert proof is not None, "Debe generar una prueba"
        
        # 5. Validar prueba
        assert hasattr(proof, 'is_valid'), "Prueba debe tener método is_valid"
        
        # Type-check con el motor cúbico
        try:
            type_checks = cubical_engine.type_checker.check_term(
                proof.context,
                proof.term,
                proof.type_
            )
            assert type_checks, "La prueba debe pasar el type-checking"
        except AttributeError:
            # Si la estructura de prueba es diferente, validar de otra forma
            assert proof is not None, "Prueba existe y fue generada"
    
    def test_sudoku_consistency_verification(self, sudoku_problem, csp_problem, cubical_engine):
        """
        Test: Sudoku → Verificación de consistencia.
        
        Verifica que la solución de un Sudoku satisface todas las restricciones
        y que esta propiedad puede ser verificada formalmente.
        """
        # Resolver
        solutions = csp_problem.solve(sudoku_problem)
        assert len(solutions) > 0, "Debe encontrar al menos una solución"
        
        solution = solutions[0]
        
        # Verificar manualmente que la solución es consistente
        # (todas las restricciones satisfechas)
        for constraint in sudoku_problem.constraints:
            vars_values = [solution[var] for var in constraint.variables]
            assert constraint.predicate(*vars_values), \
                f"Restricción {constraint} debe estar satisfecha"
        
        # Traducir a HoTT
        hott_problem = translate_csp_to_hott(sudoku_problem)
        hott_solution = translate_csp_to_hott(solution, sudoku_problem)
        
        # Verificar consistencia formalmente
        proof = verify_csp_property(
            sudoku_problem,
            solution,
            CSPProperty.CONSISTENCY,
            cubical_engine
        )
        
        assert proof is not None, "Debe generar prueba de consistencia"
    
    @pytest.mark.slow
    def test_graph_coloring_completeness(self, graph_coloring_problem, csp_problem, cubical_engine):
        """
        Test: Graph Coloring → Verificación de completitud.
        
        Verifica que la solución asigna un valor a todas las variables
        (completitud) y que esta propiedad es verificable formalmente.
        """
        # Resolver
        solutions = csp_problem.solve(graph_coloring_problem)
        assert len(solutions) > 0, "Debe encontrar al menos una solución"
        
        solution = solutions[0]
        
        # Verificar completitud manualmente
        expected_vars = set(graph_coloring_problem.variables.keys())
        solution_vars = set(solution.keys())
        assert solution_vars == expected_vars, "Solución debe asignar todas las variables"
        
        # Traducir a HoTT
        hott_problem = translate_csp_to_hott(graph_coloring_problem)
        hott_solution = translate_csp_to_hott(solution, graph_coloring_problem)
        
        # Verificar completitud formalmente
        proof = verify_csp_property(
            graph_coloring_problem,
            solution,
            CSPProperty.COMPLETENESS,
            cubical_engine
        )
        
        assert proof is not None, "Debe generar prueba de completitud"

