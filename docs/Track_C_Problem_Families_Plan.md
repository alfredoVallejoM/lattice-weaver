# Track C: Problem Families - Plan de Desarrollo

**Responsable:** Dev C (Problem Families Specialist)  
**Duraci√≥n:** 6 semanas  
**Dependencias:** D√©bil con Track A (usa API de ArcEngine)

---

## üìã Objetivo

Implementar un cat√°logo extenso de **familias de problemas CSP** con generadores param√©tricos que permitan:

1. **Generar instancias** de problemas cl√°sicos de CSP de forma program√°tica
2. **Parametrizar** la complejidad y caracter√≠sticas de cada problema
3. **Facilitar benchmarking** y experimentaci√≥n masiva
4. **Proporcionar base** para el Track H (Problemas Matem√°ticos Formales)

---

## üéØ Familias de Problemas a Implementar

### Familia 1: N-Queens (N-Reinas)

**Descripci√≥n:** Colocar N reinas en un tablero de ajedrez NxN sin que se ataquen.

**Par√°metros:**
- `n`: Tama√±o del tablero (4 ‚â§ n ‚â§ 1000)

**Variables:** `Q0, Q1, ..., Q(n-1)` (posici√≥n de cada reina)

**Dominios:** `[0, n-1]` (columna de cada reina)

**Restricciones:**
- No dos reinas en la misma columna
- No dos reinas en la misma diagonal

**Complejidad:** O(n¬≤) restricciones

---

### Familia 2: Graph Coloring (Coloraci√≥n de Grafos)

**Descripci√≥n:** Asignar colores a nodos de un grafo tal que nodos adyacentes tengan colores diferentes.

**Par√°metros:**
- `graph_type`: Tipo de grafo ('random', 'complete', 'bipartite', 'planar', 'grid')
- `n_nodes`: N√∫mero de nodos (10 ‚â§ n ‚â§ 1000)
- `n_colors`: N√∫mero de colores disponibles (2 ‚â§ k ‚â§ 10)
- `edge_probability`: Probabilidad de arista (para grafos aleatorios, 0.0 ‚â§ p ‚â§ 1.0)

**Variables:** `V0, V1, ..., V(n-1)` (color de cada nodo)

**Dominios:** `[0, k-1]` (colores disponibles)

**Restricciones:** Para cada arista (i, j): `color[i] != color[j]`

**Complejidad:** O(|E|) restricciones

---

### Familia 3: Sudoku

**Descripci√≥n:** Completar una cuadr√≠cula 9x9 con d√≠gitos 1-9 siguiendo las reglas del Sudoku.

**Par√°metros:**
- `size`: Tama√±o de la cuadr√≠cula (4, 9, 16, 25)
- `n_clues`: N√∫mero de pistas iniciales (17 ‚â§ clues ‚â§ 60 para 9x9)
- `difficulty`: Nivel de dificultad ('easy', 'medium', 'hard', 'expert')

**Variables:** `C_{i,j}` para cada celda (i, j)

**Dominios:** `[1, size]` (d√≠gitos posibles)

**Restricciones:**
- Fila: todos diferentes
- Columna: todos diferentes
- Bloque: todos diferentes

**Complejidad:** O(n¬≥) restricciones (n = size)

---

### Familia 4: Map Coloring (Coloraci√≥n de Mapas)

**Descripci√≥n:** Colorear regiones de un mapa tal que regiones adyacentes tengan colores diferentes.

**Par√°metros:**
- `map_type`: Tipo de mapa ('usa_states', 'europe', 'random_planar')
- `n_colors`: N√∫mero de colores (t√≠picamente 4)

**Variables:** `R0, R1, ..., R(n-1)` (color de cada regi√≥n)

**Dominios:** `[0, k-1]` (colores disponibles)

**Restricciones:** Para cada frontera: `color[region1] != color[region2]`

---

### Familia 5: Job Shop Scheduling

**Descripci√≥n:** Asignar trabajos a m√°quinas minimizando el tiempo total (makespan).

**Par√°metros:**
- `n_jobs`: N√∫mero de trabajos (5 ‚â§ n ‚â§ 100)
- `n_machines`: N√∫mero de m√°quinas (2 ‚â§ m ‚â§ 20)
- `max_duration`: Duraci√≥n m√°xima de cada tarea (1 ‚â§ d ‚â§ 100)

**Variables:** `Start_{job,task}` (tiempo de inicio de cada tarea)

**Dominios:** `[0, max_makespan]`

**Restricciones:**
- Precedencia: tareas del mismo trabajo en orden
- No solapamiento: tareas en la misma m√°quina no se solapan

---

### Familia 6: Latin Square

**Descripci√≥n:** Llenar una cuadr√≠cula nxn con s√≠mbolos tal que cada s√≠mbolo aparece exactamente una vez en cada fila y columna.

**Par√°metros:**
- `n`: Tama√±o de la cuadr√≠cula (3 ‚â§ n ‚â§ 100)

**Variables:** `L_{i,j}` para cada celda (i, j)

**Dominios:** `[0, n-1]` (s√≠mbolos)

**Restricciones:**
- Fila: todos diferentes (AllDifferent)
- Columna: todos diferentes (AllDifferent)

---

### Familia 7: Magic Square

**Descripci√≥n:** Llenar una cuadr√≠cula nxn con n√∫meros 1..n¬≤ tal que todas las filas, columnas y diagonales sumen lo mismo.

**Par√°metros:**
- `n`: Tama√±o de la cuadr√≠cula (3 ‚â§ n ‚â§ 10)

**Variables:** `M_{i,j}` para cada celda (i, j)

**Dominios:** `[1, n¬≤]` (n√∫meros)

**Restricciones:**
- Todos diferentes (AllDifferent global)
- Suma de cada fila = magic_constant
- Suma de cada columna = magic_constant
- Suma de cada diagonal = magic_constant

**Magic constant:** `n * (n¬≤ + 1) / 2`

---

### Familia 8: Knapsack (Mochila)

**Descripci√≥n:** Seleccionar items para maximizar valor sin exceder capacidad.

**Par√°metros:**
- `n_items`: N√∫mero de items (10 ‚â§ n ‚â§ 1000)
- `capacity`: Capacidad de la mochila (100 ‚â§ C ‚â§ 10000)
- `value_range`: Rango de valores (1, 100)
- `weight_range`: Rango de pesos (1, 100)

**Variables:** `X_i` para cada item (incluido o no)

**Dominios:** `{0, 1}` (binario)

**Restricciones:**
- Suma de pesos ‚â§ capacidad

---

### Familia 9: Zebra Puzzle (Logic Puzzles)

**Descripci√≥n:** Resolver puzzles l√≥gicos tipo "Einstein's Riddle".

**Par√°metros:**
- `n_houses`: N√∫mero de casas (t√≠picamente 5)
- `n_attributes`: N√∫mero de atributos por casa (color, nacionalidad, bebida, etc.)

**Variables:** M√∫ltiples categor√≠as de variables

**Dominios:** Valores espec√≠ficos para cada categor√≠a

**Restricciones:** L√≥gicas complejas (igualdad, adyacencia, etc.)

---

## üèóÔ∏è Arquitectura del M√≥dulo

### Estructura de Directorios

```
lattice_weaver/
‚îî‚îÄ‚îÄ problems/
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îú‚îÄ‚îÄ base.py                    # Clase base ProblemFamily
    ‚îú‚îÄ‚îÄ catalog.py                 # ProblemCatalog (registro de familias)
    ‚îú‚îÄ‚îÄ generators/
    ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ   ‚îú‚îÄ‚îÄ nqueens.py            # Generador N-Queens
    ‚îÇ   ‚îú‚îÄ‚îÄ graph_coloring.py     # Generador Graph Coloring
    ‚îÇ   ‚îú‚îÄ‚îÄ sudoku.py             # Generador Sudoku
    ‚îÇ   ‚îú‚îÄ‚îÄ map_coloring.py       # Generador Map Coloring
    ‚îÇ   ‚îú‚îÄ‚îÄ scheduling.py         # Generador Job Shop
    ‚îÇ   ‚îú‚îÄ‚îÄ latin_square.py       # Generador Latin Square
    ‚îÇ   ‚îú‚îÄ‚îÄ magic_square.py       # Generador Magic Square
    ‚îÇ   ‚îú‚îÄ‚îÄ knapsack.py           # Generador Knapsack
    ‚îÇ   ‚îî‚îÄ‚îÄ logic_puzzles.py      # Generador Logic Puzzles
    ‚îî‚îÄ‚îÄ utils/
        ‚îú‚îÄ‚îÄ __init__.py
        ‚îú‚îÄ‚îÄ graph_generators.py   # Generadores de grafos
        ‚îî‚îÄ‚îÄ validators.py         # Validadores de soluciones
```

### Clase Base: `ProblemFamily`

```python
from abc import ABC, abstractmethod
from typing import Dict, Any, List
from lattice_weaver.arc_engine import ArcEngine

class ProblemFamily(ABC):
    """
    Clase base abstracta para familias de problemas CSP.
    
    Cada familia de problemas debe implementar:
    - generate(): Generar una instancia del problema
    - validate_solution(): Validar una soluci√≥n
    - get_metadata(): Obtener metadatos del problema
    """
    
    def __init__(self, name: str, description: str):
        """
        Inicializa la familia de problemas.
        
        Args:
            name: Nombre de la familia
            description: Descripci√≥n de la familia
        """
        self.name = name
        self.description = description
    
    @abstractmethod
    def generate(self, **params) -> ArcEngine:
        """
        Genera una instancia del problema con los par√°metros dados.
        
        Args:
            **params: Par√°metros espec√≠ficos de la familia
            
        Returns:
            ArcEngine: Motor CSP configurado con el problema
        """
        pass
    
    @abstractmethod
    def validate_solution(self, solution: Dict[str, Any]) -> bool:
        """
        Valida si una soluci√≥n es correcta.
        
        Args:
            solution: Diccionario variable -> valor
            
        Returns:
            bool: True si la soluci√≥n es v√°lida
        """
        pass
    
    @abstractmethod
    def get_metadata(self, **params) -> Dict[str, Any]:
        """
        Obtiene metadatos del problema generado.
        
        Args:
            **params: Par√°metros del problema
            
        Returns:
            Dict con metadatos (complejidad, # variables, # restricciones, etc.)
        """
        pass
    
    def get_default_params(self) -> Dict[str, Any]:
        """
        Retorna par√°metros por defecto para esta familia.
        
        Returns:
            Dict con par√°metros por defecto
        """
        return {}
```

### Clase `ProblemCatalog`

```python
from typing import Dict, List, Optional
from .base import ProblemFamily

class ProblemCatalog:
    """
    Cat√°logo centralizado de familias de problemas CSP.
    
    Permite registrar, buscar y listar familias de problemas.
    """
    
    def __init__(self):
        """Inicializa el cat√°logo vac√≠o."""
        self._families: Dict[str, ProblemFamily] = {}
    
    def register(self, family: ProblemFamily):
        """
        Registra una familia de problemas en el cat√°logo.
        
        Args:
            family: Instancia de ProblemFamily
        """
        if family.name in self._families:
            raise ValueError(f"Family '{family.name}' already registered")
        self._families[family.name] = family
    
    def get(self, name: str) -> Optional[ProblemFamily]:
        """
        Obtiene una familia por nombre.
        
        Args:
            name: Nombre de la familia
            
        Returns:
            ProblemFamily o None si no existe
        """
        return self._families.get(name)
    
    def list_families(self) -> List[str]:
        """
        Lista todas las familias registradas.
        
        Returns:
            Lista de nombres de familias
        """
        return list(self._families.keys())
    
    def generate_problem(self, family_name: str, **params) -> ArcEngine:
        """
        Genera un problema de una familia espec√≠fica.
        
        Args:
            family_name: Nombre de la familia
            **params: Par√°metros del problema
            
        Returns:
            ArcEngine configurado
        """
        family = self.get(family_name)
        if family is None:
            raise ValueError(f"Unknown family: {family_name}")
        return family.generate(**params)

# Instancia global del cat√°logo
_catalog = ProblemCatalog()

def get_catalog() -> ProblemCatalog:
    """Retorna la instancia global del cat√°logo."""
    return _catalog
```

---

## üìÖ Plan de Implementaci√≥n (6 Semanas)

### Semana 1: Infraestructura Base

**Tareas:**
1. Crear estructura de directorios
2. Implementar `ProblemFamily` (clase base)
3. Implementar `ProblemCatalog`
4. Implementar utilidades (`graph_generators.py`, `validators.py`)
5. Tests unitarios de infraestructura

**Entregables:**
- `lattice_weaver/problems/base.py`
- `lattice_weaver/problems/catalog.py`
- `lattice_weaver/problems/utils/`
- `tests/unit/test_problem_base.py`
- `tests/unit/test_catalog.py`

---

### Semana 2: Familias B√°sicas (1-3)

**Tareas:**
1. Implementar `NQueensProblem`
2. Implementar `GraphColoringProblem`
3. Implementar `SudokuProblem`
4. Tests unitarios para cada familia
5. Tests de integraci√≥n

**Entregables:**
- `lattice_weaver/problems/generators/nqueens.py`
- `lattice_weaver/problems/generators/graph_coloring.py`
- `lattice_weaver/problems/generators/sudoku.py`
- Tests correspondientes

---

### Semana 3: Familias Intermedias (4-6)

**Tareas:**
1. Implementar `MapColoringProblem`
2. Implementar `JobShopSchedulingProblem`
3. Implementar `LatinSquareProblem`
4. Tests unitarios
5. Benchmarks de rendimiento

**Entregables:**
- Generadores correspondientes
- Tests y benchmarks

---

### Semana 4: Familias Avanzadas (7-9)

**Tareas:**
1. Implementar `MagicSquareProblem`
2. Implementar `KnapsackProblem`
3. Implementar `LogicPuzzlesProblem` (Zebra, Einstein)
4. Tests unitarios
5. Documentaci√≥n de API

**Entregables:**
- Generadores correspondientes
- Documentaci√≥n completa

---

### Semana 5: Experimentaci√≥n y Benchmarking

**Tareas:**
1. Suite de experimentaci√≥n masiva
2. Generaci√≥n de datasets de benchmarking
3. An√°lisis de complejidad emp√≠rica
4. Visualizaciones de resultados
5. Documentaci√≥n de experimentos

**Entregables:**
- `lattice_weaver/problems/experiments/`
- Datasets de benchmarking
- Reportes de an√°lisis

---

### Semana 6: Integraci√≥n y Documentaci√≥n Final

**Tareas:**
1. Integraci√≥n con Track A (ArcEngine)
2. Preparaci√≥n para Track H (Formal Math)
3. Documentaci√≥n exhaustiva
4. Tutoriales y ejemplos
5. Empaquetado y entrega

**Entregables:**
- Documentaci√≥n completa
- Tutoriales
- `track-c-families-v1.0.tar.gz`

---

## üß™ Estrategia de Testing

### Tests Unitarios

Para cada familia de problemas:

```python
def test_nqueens_generation():
    """Test que N-Queens genera correctamente."""
    family = NQueensProblem()
    engine = family.generate(n=8)
    assert len(engine.variables) == 8
    assert len(engine.constraints) == 28  # 8*7/2 = 28

def test_nqueens_solution_validation():
    """Test que valida soluciones correctas."""
    family = NQueensProblem()
    solution = {'Q0': 0, 'Q1': 4, 'Q2': 7, 'Q3': 5, 
                'Q4': 2, 'Q5': 6, 'Q6': 1, 'Q7': 3}
    assert family.validate_solution(solution) == True

def test_nqueens_metadata():
    """Test que metadatos son correctos."""
    family = NQueensProblem()
    metadata = family.get_metadata(n=8)
    assert metadata['n_variables'] == 8
    assert metadata['n_constraints'] == 28
    assert metadata['complexity'] == 'O(n^2)'
```

### Tests de Integraci√≥n

```python
def test_catalog_registration():
    """Test que el cat√°logo registra familias."""
    catalog = get_catalog()
    assert 'nqueens' in catalog.list_families()
    assert 'graph_coloring' in catalog.list_families()

def test_end_to_end_nqueens():
    """Test end-to-end: generar y resolver N-Queens."""
    catalog = get_catalog()
    engine = catalog.generate_problem('nqueens', n=8)
    from lattice_weaver.arc_engine import CSPSolver
    solver = CSPSolver(engine)
    solution = solver.solve()
    assert solution is not None
    family = catalog.get('nqueens')
    assert family.validate_solution(solution) == True
```

### Benchmarks

```python
@pytest.mark.benchmark
def test_nqueens_performance(benchmark):
    """Benchmark de generaci√≥n de N-Queens."""
    family = NQueensProblem()
    result = benchmark(family.generate, n=100)
    assert result is not None
```

---

## üìê Principios de Dise√±o

### 1. Modularidad

Cada familia de problemas es un m√≥dulo independiente que puede desarrollarse y testearse por separado.

### 2. Extensibilidad

Nuevas familias se a√±aden simplemente creando una nueva clase que herede de `ProblemFamily` y registr√°ndola en el cat√°logo.

### 3. Parametrizaci√≥n

Todos los aspectos relevantes de cada problema son parametrizables para facilitar experimentaci√≥n.

### 4. Validaci√≥n

Cada familia incluye un validador de soluciones para verificar correcci√≥n.

### 5. Metadatos

Cada problema generado incluye metadatos (complejidad, tama√±o, etc.) para an√°lisis posterior.

---

## üîó Dependencias con Otros Tracks

### Track A (Core Engine)

**Dependencia:** D√©bil (interfaz)

**Uso:** `ProblemFamily.generate()` retorna un `ArcEngine` configurado

**Interfaz:**
```python
from lattice_weaver.arc_engine import ArcEngine

def generate(self, **params) -> ArcEngine:
    engine = ArcEngine()
    engine.add_variable(...)
    engine.add_constraint(...)
    return engine
```

### Track H (Formal Math)

**Dependencia:** Track H depende de Track C

**Provisi√≥n:** Cat√°logo de familias de problemas como base para problemas matem√°ticos formales

**Interfaz:**
```python
from lattice_weaver.problems import get_catalog

catalog = get_catalog()
# Track H puede extender familias existentes o crear nuevas
```

---

## üìä M√©tricas de √âxito

- ‚úÖ 9 familias de problemas implementadas
- ‚úÖ 100% cobertura de tests
- ‚úÖ Documentaci√≥n completa de API
- ‚úÖ 3+ tutoriales de uso
- ‚úÖ Suite de benchmarking funcional
- ‚úÖ Integraci√≥n exitosa con Track A

---

## üìö Referencias

1. Dechter, R. (2003). *Constraint Processing*. Morgan Kaufmann.
2. Russell, S., & Norvig, P. (2020). *Artificial Intelligence: A Modern Approach* (4th ed.). Pearson.
3. CSPLib: A problem library for constraints - http://www.csplib.org/
4. Benchmarking Constraint Programming - https://www.cs.ox.ac.uk/files/2366/RR-09-07.pdf

---

**√öltima actualizaci√≥n:** 12 de Octubre, 2025  
**Estado:** Planificaci√≥n completa - Listo para implementaci√≥n

